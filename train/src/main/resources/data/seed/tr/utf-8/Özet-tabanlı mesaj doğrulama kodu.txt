Kriptografide, özet tabanlı mesaj doğrulama kodu (HMAC), kriptografik özet fonksiyonu ve gizli bir kriptografik anahtar içeren bir mesaj doğrulama kodu (MDK veya MAC) türüdür. Diğer MAC türleri gibi, HMAC de hem veri bütünlüğünü kontrol etmek hem de mesaj içeriğini onaylamakta kullanılabilir. HMAC in hesaplanmasında herhangi bir kriptografik özet fonksiyonu kullanılabilir. Örneğin, HMAC in hesaplanmasında MD5 veya SHA-1 özet fonksiyonu kullanılması durumunda, ilgili MAC algoritması da buna uygun olarak HMAC-MD5 veya HMAC-SHA1 olarak isimlendirilebilir. HMAC'in kriptografik saldırılara karşı dayanıklılığı, kullanılan özet fonksiyonunun dayanıklılığına, elde edilen özetin boyutuna, kullanılan kriptografik anahtarın boyutuna ve kalitesine bağlıdır.

Ötelemeli bir özet fonksiyonu, iletilmek istenen mesajı belirli bir boyuttaki bloklara bölerek sırasıyla bu bloklar üzerinde bir sıkıştırma fonksiyonu uygular. Örneğin, MD5 ve SHA-1 özet fonksiyonları 512 bitlik bloklar kullanır. Üretilen HMAC'in boyutu, gerektiğinde kesilerek azaltılabilse de, genelde bu işlem için kullanılan özet fonksiyonun boyutuyla aynıdır (MD5 ve SHA-1 özetleri için sırasıyla 128 ve 160 bit).
HMAC iletilmek istenen mesajı şifrelemez. Bunun yerine mesaj (şifreli veya değil) ve HMAC özeti beraber iletilir. Gizli anahtara sahip taraf, mesajın yeniden özetini alıp, bunu mesajla birlikte gönderilen özetle karşılaştırır. Eğer elde edilen yeni özet mesajla birlikte gönderilen özetle eşleşirse mesaj doğrulanmış olur.
HMAC yapısı ve ilgili analizler ilk defa 1996'da Bellare|Mihir Bellare, Ran Canetti, ve Hugo Krawczyk  (aynı zamanda RFC 2014 ün yazarıdır) tarafından yayınlanmıştır. İlgili makalede, nadiren de olsa kullanılan bir MAC çeşidi olan NMAC de tanımlanmıştır. FIPS PUB 198 ise HMAC'leri standartlaştırmıştır. HMAC-SHA1 ve HMAC-MD5, IPsec ve TLS protokolleri ile beraber kullanılmaktadır.
The definition and analysis of the HMAC construction was first published in 1996 by Mihir Bellare, Ran Canetti, and Hugo Krawcho also wrote RFC 2104.  This paper also defined a variant called NMAC that is rarely, if ever, used. FIPS PUB 198 generalizes and standardizes the use of HMACs. HMAC-SHA1 and HMAC-MD5 are used within the IPsec and TLS protocols.


Tanım
Aşağıdaki tanımlar RFC 2104 protokolünden alınmıştır:

  
    
      
        
          
            HMAC
          
        
        (
        K
        ,
        m
        )
        =
        H
        
          
            (
          
        
        (
        
          K
          ′
        
        ⊕
        o
        p
        a
        d
        )
        
        
          |
        
        
          |
        
        
        H
        
          
            (
          
        
        (
        
          K
          ′
        
        ⊕
        i
        p
        a
        d
        )
        
        
          |
        
        
          |
        
        
        m
        
          
            )
          
        
        
          
            )
          
        
      
    
    {\displaystyle {\textit {HMAC}}(K,m)=H{\Bigl (}(K'\oplus opad)\;||\;H{\bigl (}(K'\oplus ipad)\;||\;m{\bigr )}{\Bigr )}}
  
burada,

H herhangi bir kriptografik özet fonksiyonu,
K gizli anahtar,
m doğrulanması istenen mesaj,
K' orijinal anahtar K dan türetilen yeni bir gizli anahtar,
|| birleştirme işlemi,
⊕ özel veya, exclusive or (XOR) işlemi,
opad dış tamamlama (padding),
ve ipad iç tamamlama (padding) olarak verilmiştir.


Uygulama
Aşağıda verilen sözde kod (pseudocode) HMAC'in yazılımsal olarak nasıl uygulanabileceğini göstermektedir. Blok boyutu, SHA-1, MD5, RIPEMD-128/16064 özet fonksiyonlarından birisi kullanılıyorsa 64 byte olarak alınır.
 function hmac (key, message) {
    if (length(key) > blocksize) {
        key = hash(key) // keys longer than blocksize are shortened
    }
    if (length(key) < blocksize) {
        // keys shorter than blocksize are zero-padded (where ∥ is concatenation)
        key = key ∥ [0x00 * (blocksize - length(key))] // Where * is repetition.
    }
   
    o_key_pad = [0x5c * blocksize] ⊕ key // Where blocksize is that of the underlying hash function
    i_key_pad = [0x36 * blocksize] ⊕ key // Where ⊕ is exclusive or (XOR)
   
    return hash(o_key_pad ∥ hash(i_key_pad ∥ message)) // Where ∥ is concatenation
}


Dizayn Temelleri
HMAC’in tasarımında, anahtar ve özet fonksiyonu kullanan daha basit mesaj doğrulama kodu (MAC) mekanizmalarındaki güvenlik açıkları etkili olmuştur. Örneğin, HMAC’in sağladığı güvenliğe denk seviyedeki bir güvenliğin, MAC = H(key ∥ message) özet fonksiyonu kullanılarak oluşturulan daha basit bir mekanizmayla da elde edilebileceği varsayılabilir. Fakat, bu varsayım ciddi bir güvenlik açığı barındırmaktadır: çoğu özet fonksiyonun tasarımı, kullanılan kriptografik anahtar bilinmese dahi, orijinal mesaja ekleme yaparak yeni bir mesaj oluşturmaya ve bu oluşturulan yeni mesaj için gerçekte var olmayan geçerli bir MAC değeri elde edilmesine izin vermektedir ("uzunluk-genişletme-saldırısı"). Diğer bir HMAC alternatifi olan, MAC = H(message ∥ key) mekanizmasındaki sorun ise, kullanılan özet fonksiyonda oluşabilecek bir çakışmanın MAC teki bir çakışmaya neden olmasıdır (aynı özete sahip olan m1 ve m² mesajları, eklenen anahtarın özeti alınmadan önceki özet fonksiyonuna aynı başlangıç şartlarını verecektir, böylece son hash değerleri aynı olacaktır). Son olarak, başka bir HMAC alternatifi olan MAC = H(key ∥ message ∥ key) mekanizmasını kullanmak daha makul görünse de, güvenlik alanında yazılmış bazı makaleler, iki farklı anahtar kullanılsa dahi bu yaklaşımın da çeşitli güvenlik açıkları barındırdığından bahsetmektedir.Şu an kullanılmakta olan HMAC mekanizması, HMAC = H(key ∥ H(key ∥ message)) biçiminde tasarlanmış olup, bu mekanizma için var olan herhangi biruzunluk-genişletme-saldırısı bilinmemektedir. Bunun nedeni, çift özet fonksiyonu kullanımı sonucu içerideki özet fonksiyonunun ürettiği ara çıktının dışarıdaki özet fonksiyonu tarafından maskelenmesidir. Yukarıda tarifi verilen algoritmanın güvenliği için kullanılan ipad ve opad değerleri kritik bir öneme sahip olmasa da, bu değerler, iç ve dış anahtarların az sayıda ortak bit değeri içermesi için aralarındaki Hamming uzaklığı fazla olacak şekilde tanımlanmalıdır. Güvenlikle ilgili yapılan tümden gelim çalışmalarında, HMAC’in güvenliği için gizli anahtarlar arası en az bir bitlik bir fark olması gerektiği vurgulanmıştır.NIST tarafından SHA-3 yarışmasının birincisi olarak seçilen Keccack özet fonksiyonu, “uzunluk-genişletme-saldırılarına" karşı güvenli olmasından dolayı, yukarıda tanımlanan iç içe geçmiş özet fonksiyon yapısına gerek kalmadan sadece gizli anahtarın mesajın önüne eklenmesi ve elde edilen ifadenin özetinin alınmasıyla MAC elde etmek için kullanılabilir.


Güvenlik
HMAC’in kriptografik direnci kullanılan gizli anahtarın boyutuna bağlıdır. HMAC’e karşı yapılan en yaygın saldırı gizli anahtarı ele geçirmeyi hedefleyen kaba kuvvet atağıdır. HMAC’ler çakışmalardan, yapılarındaki özet algoritmalarına oranla çok daha az etkilenirler. Bu nedenle, HMAC-MD5 mesaj doğrulama kodu, MD5 özetleme algoritmasındaki zayıflıklardan etkilenmez.
2006’da, Jongsung Kim, Alex Biryukov, Bart Preneel, ve Seokhie Hong basitleştirilmiş MD5 veya SHA-1 ya da tam [1], [2] ve SHA-0 özet fonksiyonlarını kullanan HMAC’lerin, rastgele bir fonksiyondan veya rastgele bir fonksiyon kullanan HMAC’ten nasıl ayırt edilebileceğini gösterdi. Diferansiyel kripto analizde bir konsept olan diferansiyel ayırt ediciler bir saldırganın HMAC üzerinde varoluşsal sahtecilik saldırıları gerçekleştirmesine izin vermektedir. Ayrıca, diferansiyel ayırt ediciler ikinci-öngörüntü saldırılarına neden olabilir. MD4’ün tam sürümünü kullanan HMAC bu bilgi sayesinde saldırıya uğrayabilir. Bu tip saldırılar HMAC’in güvenliğine dair ispata ters düşmeyip, aynı zamanda var olan kriptografik özet fonksiyonlarını baz alarak HMAC hakkında öngörüler sunmaktadır.2009’da, Xiaoyun Wang ve diğerleri ilgili gizli anahtarları kullanmadan HMAC-MD5 için bir ayırt etme saldırısı ortaya koydular. Bu saldırı, MD5 tabanlı bir HMAC örneğini rastgele bir fonksiyon tabanlı HMAC örneğinden 297 sorguyla ve 0.87 olasılıkla ayırt edebilmektedir.2011’de, MD5’teki ve HMAC-MD5’teki güvenlik hususlarını güncellemek amacıyla RFC 6151 onaylandı. RFC’de HMAC-MD5 için,  – MD5 özet fonksiyonunun kendisinin güvenliği ciddi bir biçimde zafiyete uğrasa da – şu anda HMAC-MD5 mesaj doğrulama koduna yönelik bilinen güncel saldırılar pratikte bir güvenlik açığı teşkil etmemektedir.


Örnek
Bazı boş HMAC değerleri:

HMAC_MD5("", "")    = 0x74e6f7298a9c2d168935f58c001bad88
HMAC_SHA1("", "")   = 0xfbdb1d1b18aa6c08324b7d64b71fb76370690e1d
HMAC_SHA256("", "") = 0xb613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c712144292c5ad

Bazı dolu HMAC değerleri, 8-bit ASCII veya UTF-8 kodlama:

HMAC_MD5("key", "The quick brown fox jumps over the lazy dog")    = 0x80070713463e7749b90c2dc24911e275
HMAC_SHA1("key", "The quick brown fox jumps over the lazy dog")   = 0xde7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9
HMAC_SHA256("key", "The quick brown fox jumps over the lazy dog") = 0xf7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc2d1a3cd8


Kaynakça

Notlar


Dış bağlantılar
RFC2104
Online HMAC Calculator for dozens of underlying hashing algorithms
Online HMAC Generator / Tester Tool
FIPS PUB 198-1, The Keyed-Hash Message Authentication Code (HMAC)
PHP HMAC implementation
Python HMAC implementation
Perl HMAC implementation
Ruby HMAC implementation
C HMAC implementation
C++ HMAC implementation (part of Crypto++)
Java implementation
JavaScript MD5 and SHA HMAC implementation
JavaScript SHA-only HMAC implementation
.NET's System.Security.Cryptography.HMAC
Delphi/Free Pascal implementationŞablon:Cryptography navbox
Şablon:Use dmy dates